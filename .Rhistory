targets::tar_make()
targets::tar_visnetwork()
# heart rate
heart_rate_model <- lmer(value ~ condition*minute + (condition + minute | subject_number),
data = heart_rate_data,
REML = TRUE)
# heart rate
heart_rate_model <- lmer(value ~ condition*minute + (condition + minute | subject_number),
data = heart_rate_data,
REML = TRUE, control = lmerControl(optimizer = "Nelder-Mead"))
# heart rate
heart_rate_model <- lmer(value ~ condition*minute + (condition + minute | subject_number),
data = heart_rate_data,
REML = TRUE, control = lmerControl(optimizer = "NelderMead"))
# heart rate
heart_rate_model <- lmer(value ~ condition*minute + (condition + minute | subject_number),
data = heart_rate_data,
REML = TRUE, control = lmerControl(optim = "NelderMead"))
# heart rate
heart_rate_model <- lmer(value ~ condition*minute + (condition + minute | subject_number),
data = heart_rate_data,
REML = TRUE, control = lmerControl(optim = "Nelder-Mead"))
# heart rate
heart_rate_model <- lmer(value ~ condition*minute + (condition + minute | subject_number),
data = heart_rate_data,
REML = TRUE, control = lmerControl(optimizer = "Nelder_Mead"))
# heart rate
heart_rate_model <- lmer(value ~ condition*minute + (condition + minute | subject_number),
data = heart_rate_data,
REML = TRUE, control = lmerControl(optimizer = "nloptwrap"))
# heart rate
heart_rate_model <- lmer(value ~ condition*minute + (condition + minute | subject_number),
data = heart_rate_data,
REML = TRUE,
control = lmerControl(calc.derivs = FALSE))
sjPlot::plot_model(heart_rate_model, type = "pred", terms = c("minute", "condition"),
show.data = TRUE, jitter = TRUE)
sjPlot::plot_model(heart_rate_model, type="re")
# heart rate
heart_rate_model <- lmer(value ~ condition*minute + (condition *minute | subject_number),
data = heart_rate_data,
REML = TRUE,
control = lmerControl(calc.derivs = FALSE)) # to enable convergence with condition random slopes
sjPlot::plot_model(heart_rate_model, type = "pred", terms = c("minute", "condition"),
show.data = TRUE, jitter = TRUE)
sjPlot::plot_model(heart_rate_model, type="re")
sit_reach_model <- lmer(value ~ condition*timepoint + measurement + (condition*timepoint*measurement | subject_number),
data = sit_reach_data,
REML = TRUE)
sit_reach_model <- lmer(value ~ condition*timepoint + measurement + (condition*timepoint + measurement | subject_number),
data = sit_reach_data,
REML = TRUE)
sit_reach_model <- lmer(value ~ condition*timepoint + measurement + (condition*timepoint + measurement | subject_number),
data = sit_reach_data,
REML = TRUE,
control = lmerControl(calc.derivs = FALSE)) # to enable convergence with condition and condition:minute random slopes
sjPlot::plot_model(sit_reach_model, type = "pred", terms = c("condition", "timepoint", "measurement"))
sjPlot::plot_model(sit_reach_model)
# lactate
lactate_model <- lmer(value ~ condition*timepoint + (1 | subject_number),
data = lactate_data,
REML = TRUE)
# lactate
lactate_model <- lmer(value ~ condition*timepoint + (condition | subject_number),
data = lactate_data,
REML = TRUE)
# lactate
lactate_model <- lmer(value ~ condition*timepoint + (timepoint | subject_number),
data = lactate_data,
REML = TRUE)
# sprint
sprint_model <- lmer(value ~ condition*distance + (distance*condition | subject_number),
data = sprint_data,
REML = TRUE)
sprint_model
# sprint
sprint_model <- lmer(value ~ condition*distance + (distance + condition | subject_number),
data = sprint_data,
REML = TRUE)
# heart rate
heart_rate_model <- lmer(value ~ condition*minute + (condition + minute | subject_number),
data = heart_rate_data,
REML = TRUE,
control = lmerControl(calc.derivs = FALSE)) # to enable convergence with condition and condition:minute random slopes
sit_reach_model <- lmer(value ~ condition*timepoint + measurement + (condition + timepoint + measurement | subject_number),
data = sit_reach_data,
REML = TRUE,
control = lmerControl(calc.derivs = FALSE)) # to enable convergence with condition and condition:minute random slopes
sit_reach_model <- lmer(value ~ condition*timepoint + measurement + (condition + timepoint + measurement | subject_number),
data = sit_reach_data,
REML = TRUE)
sit_reach_model <- lmer(value ~ condition*timepoint + measurement + (condition + timepoint + measurement | subject_number),
data = sit_reach_data,
REML = TRUE)
sjPlot::plot_model(sit_reach_model, type = "pred", terms = c("condition", "timepoint", "measurement"))
sjPlot::plot_model(sit_reach_model)
lactate_data
borg_rpe_data
heart_rate_data
cmj_data
# cmj
cmj_model <- lmer(value ~ condition + measurement + (1 | subject_number),
data = cmj_data,
REML = TRUE)
sjPlot::plot_model(cmj_model, type = "pred", terms = "condition",
show.data = TRUE, jitter = TRUE)
# cmj
cmj_model <- lmer(value ~ condition + (1 | subject_number),
data = cmj_data,
REML = TRUE)
sjPlot::plot_model(cmj_model, type = "pred", terms = "condition",
show.data = TRUE, jitter = TRUE)
# cmj
cmj_model <- lmer(value ~ condition + (condition | subject_number),
data = cmj_data,
REML = TRUE)
# heart rate
heart_rate_model <- lmer(value ~ condition*minute + (condition*minute | subject_number),
data = heart_rate_data,
REML = TRUE,
control = lmerControl(calc.derivs = FALSE)) # to enable convergence with condition random slopes
sit_reach_model <- lmer(value ~ condition*timepoint + measurement + (condition * timepoint + measurement | subject_number),
data = sit_reach_data,
REML = TRUE)
sit_reach_model <- lmer(value ~ condition*timepoint + measurement + (condition * timepoint + measurement | subject_number),
data = sit_reach_data,
REML = TRUE,
control = lmerControl(calc.derivs = FALSE)) # to enable convergence with condition and condition:minute random slopes
sjPlot::plot_model(sit_reach_model, type = "pred", terms = c("condition", "timepoint", "measurement"))
sjPlot::plot_model(sit_reach_model)
sit_reach_model <- lmer(value ~ condition*timepoint*measurement + (condition * timepoint + measurement | subject_number),
data = sit_reach_data,
REML = TRUE,
control = lmerControl(calc.derivs = FALSE)) # to enable convergence with condition and condition:minute random slopes
sit_reach_model <- lmer(value ~ condition*timepoint*measurement + (condition * timepoint * measurement | subject_number),
data = sit_reach_data,
REML = TRUE,
control = lmerControl(calc.derivs = FALSE)) # to enable convergence with condition and condition:minute random slopes
sit_reach_model <- lmer(value ~ condition*timepoint + measurement + (condition * timepoint + measurement | subject_number),
data = sit_reach_data,
REML = TRUE,
control = lmerControl(calc.derivs = FALSE)) # to enable convergence with condition and condition:minute random slopes
# sprint
sprint_model <- lmer(value ~ condition*distance + (condition*distance | subject_number),
data = sprint_data,
REML = TRUE)
sprint_model
sjPlot::plot_model(sprint_model, type = "pred", terms = c("distance", "condition"),
show.data = TRUE, jitter = TRUE)
targets::tar_visnetwork()
renv::install("broom.mixed")
targets::tar_make()
renv::install("lmerTest")
targets::tar_make()
targets::tar_make()
targets::tar_load(sprint_model)
sprint_model
targets::tar_visnetwork()
targets::tar_make()
targets::tar_load(c(sit_reach_model,lactate_model))
targets::tar_load(c(sit_reach_model,lactate_model, borg_rpe_model,heart_rate_model,cmj_model,sprint_model,imtp_model))
renv::install("performance")
library(performance)
check_model(sit_reach_model)
check_model(sit_reach_model)
check_model(lactate_model)
# lactate
lactate_model <- lmer(value ~ condition*timepoint + (1 | subject_number) + (1|condition),
data = lactate_data,
REML = TRUE)
# lactate
lactate_model <- lmer(log(value) ~ condition*timepoint + (1 | subject_number),
data = lactate_data,
REML = TRUE)
sjPlot::plot_model(lactate_model, type = "pred", terms = c("condition", "timepoint"),
show.data = TRUE, jitter = TRUE)
check_model(lactate_model)
sjPlot::plot_model(borg_rpe_model, type = "pred", terms = "condition",
show.data = TRUE, jitter = TRUE)
sjPlot::plot_model(lactate_model, type = "pred", terms = c("condition", "timepoint"),
show.data = TRUE, jitter = TRUE)
sjPlot::plot_model(lactate_model, type = "pred", terms = c("timepoint", "condition"),
show.data = TRUE, jitter = TRUE)
# lactate
lactate_model <- lmer(log(value) ~ condition*factor(timepoint) + (1 | subject_number),
data = lactate_data,
REML = TRUE)
sjPlot::plot_model(lactate_model, type = "pred", terms = c("timepoint", "condition"),
show.data = TRUE, jitter = TRUE)
check_model(lactate_model)
check_normality(lactate_model)
plot(check_normality(lactate_model), type = "pp")
qqnorm(resid(lactate_model))
qqline(resid(lactate_model))
plot(check_normality(lactate_model), type = "qq")
renv::install("qqplotr")
plot(check_normality(lactate_model), type = "qq")
check_model(lactate_model)
check_model(borg_rpe_model)
check_model(heart_rate_model)
check_model(cmj_model)
check_model(sprint_model)
check_model(imtp_model)
check_homogeneity(imtp_model)
?check_model
check_model(lactate_model,detrend = TRUE)
renv::install("equatiomatic")
renv::install("equatiomatic")
remotes::install_github("datalorax/equatiomatic")
install.packages("remoted")
install.packages("remotes")
remotes::install_github("datalorax/equatiomatic")
### Explore data for variables with multiple measurements to determine whether to include as predictor
sit_reach_data |>
group_by(condition,measurement,timepoint) |>
summarise(mean = mean(value, na.rm=TRUE),
sd = sd(value, na.rm=TRUE)) |>
ggplot(aes(x=factor(measurement))) +
geom_line(data = sit_reach_data,
aes(y = value, group=interaction(condition, subject_number, timepoint)),
position = position_jitter(w=0.1),
alpha = 0.5, size = 0.5) +
geom_pointrange(aes(y=mean, ymin=mean-sd, ymax=mean+sd)) +
geom_line(aes(y=mean, group=interaction(condition, timepoint)),
size = 1) +
facet_grid("Condition" + condition ~ "Timepoint" + timepoint) +
labs(
x = "Measurement",
y = "Sit and Reach (cm)"
) +
theme_bw()
sit_reach_data <- sit_reach_data |>
mutate(
condition = case_when(
condition == "no" ~ "Control",
condition == "low" ~ "Low BFR",
condition == "high" ~ "High BFR"
),
timepoint = factor(
case_when(
timepoint == 0 ~ "Pre",
timepoint == 1 ~ "Post"
),
levels = c("Pre", "Post")
),
condition_lab = "Condition",
timepoint_lab = "Timepoint"
)
sit_reach_data |>
group_by(condition,measurement,timepoint) |>
summarise(mean = mean(value, na.rm=TRUE),
sd = sd(value, na.rm=TRUE)) |>
mutate(
condition_lab = "Condition",
timepoint_lab = "Timepoint"
) |>
ggplot(aes(x=factor(measurement))) +
geom_line(data = sit_reach_data,
aes(y = value, group=interaction(condition, subject_number, timepoint)),
position = position_jitter(w=0.1),
alpha = 0.5, size = 0.5) +
geom_pointrange(aes(y=mean, ymin=mean-sd, ymax=mean+sd)) +
geom_line(aes(y=mean, group=interaction(condition, timepoint)),
size = 1) +
ggh4x::facet_nested(condition_lab + condition ~ timepoint_lab + timepoint) +
labs(
x = "Measurement",
y = "Sit and Reach (cm)"
) +
theme_bw()
equatiomatic::extract_eq(sit_reach_model)
#| message: false
#| warning: false
#| echo: false
targets::tar_load(sit_reach_model)
check_model(sit_reach_model)
#| message: false
#| warning: false
#| echo: false
#| label: fig-measurement
#| fig-width: 7.5
#| fig-height: 10
#| fig-cap: Individual participant data (thin lines) with means (points) an standard deviations (error bars).
targets::tar_load(sit_reach_data)
sit_reach_data <- sit_reach_data |>
mutate(
condition = case_when(
condition == "no" ~ "Control",
condition == "low" ~ "Low BFR",
condition == "high" ~ "High BFR"
),
timepoint = factor(
case_when(
timepoint == 0 ~ "Pre",
timepoint == 1 ~ "Post"
),
levels = c("Pre", "Post")
),
condition_lab = "Condition",
timepoint_lab = "Timepoint"
)
sit_reach_data |>
group_by(condition,measurement,timepoint) |>
summarise(mean = mean(value, na.rm=TRUE),
sd = sd(value, na.rm=TRUE)) |>
mutate(
condition_lab = "Condition",
timepoint_lab = "Timepoint"
) |>
ggplot(aes(x=factor(measurement))) +
geom_line(data = sit_reach_data,
aes(y = value, group=interaction(condition, subject_number, timepoint)),
position = position_jitter(w=0.1),
alpha = 0.5, size = 0.5) +
geom_pointrange(aes(y=mean, ymin=mean-sd, ymax=mean+sd)) +
geom_line(aes(y=mean, group=interaction(condition, timepoint)),
size = 1) +
ggh4x::facet_nested(condition_lab + condition ~ timepoint_lab + timepoint) +
labs(
x = "Measurement",
y = "Sit and Reach (cm)"
) +
theme_bw()
#| message: false
#| warning: false
#| echo: false
#| label: fig-measurement
#| fig-width: 7.5
#| fig-height: 12.5
#| fig-cap: Individual participant data (thin lines) with means (points) an standard deviations (error bars).
targets::tar_load(sit_reach_data)
sit_reach_data <- sit_reach_data |>
mutate(
condition = case_when(
condition == "no" ~ "Control",
condition == "low" ~ "Low BFR",
condition == "high" ~ "High BFR"
),
timepoint = factor(
case_when(
timepoint == 0 ~ "Pre",
timepoint == 1 ~ "Post"
),
levels = c("Pre", "Post")
),
condition_lab = "Condition",
timepoint_lab = "Timepoint"
)
sit_reach_data |>
group_by(condition,measurement,timepoint) |>
summarise(mean = mean(value, na.rm=TRUE),
sd = sd(value, na.rm=TRUE)) |>
mutate(
condition_lab = "Condition",
timepoint_lab = "Timepoint"
) |>
ggplot(aes(x=factor(measurement))) +
geom_line(data = sit_reach_data,
aes(y = value, group=interaction(condition, subject_number, timepoint)),
position = position_jitter(w=0.1),
alpha = 0.5, size = 0.5) +
geom_pointrange(aes(y=mean, ymin=mean-sd, ymax=mean+sd)) +
geom_line(aes(y=mean, group=interaction(condition, timepoint)),
size = 1) +
ggh4x::facet_nested(condition_lab + condition ~ timepoint_lab + timepoint) +
labs(
x = "Measurement",
y = "Sit and Reach (cm)"
) +
theme_bw()
check_model()
check_model(sit_reach_model)
check_predictions(sit_reach_model)
check_homogeneity(sit_reach_model)
check_heteroscedasticity(sit_reach_model)
t <- check_homogeneity(sit_reach_model)
t
t[1]
round(check_homogeneity(sit_reach_model)[1],3)
check_normality(sit_reach_model)
parameters:::model_parameters(sit_reach_model, vcov = "HC3")
parameters:::model_parameters(sit_reach_model, vcov = "HC3")
sit_reach_model
check_normality(sit_reach_model)
check_model(sit_reach_model)
check_collinearity(sit_reach_model)
check_outliers(sit_reach_model)
out <- check_outliers(sit_reach_model)
out[1]
out
paste(out)
countif(out == TRUE)
n_distinct(out)
check_outliers(lactate_model)
n_distinct(check_outliers(lactate_model))
length(out["TRUE"])
sum(out)
sum(check_outliers(lactate_model))
length(out)
out
binned_residuals(sit_reach_model)
check_normality(sit_reach_model, effects = "random")
ran <- check_normality(sit_reach_model, effects = "random")
ran
max(ran)
round((sum(check_outliers(sit_reach_model))/length(check_outliers(sit_reach_model)))*100
round((sum(check_outliers(sit_reach_model))/length(check_outliers(sit_reach_model))))*100
(sum(check_outliers(sit_reach_model))/length(check_outliers(sit_reach_model)))
round((sum(check_outliers(sit_reach_model))/length(check_outliers(sit_reach_model)))*100)
round((sum(check_outliers(sit_reach_model))/length(check_outliers(sit_reach_model))))*100
round((sum(check_outliers(sit_reach_model))/length(check_outliers(sit_reach_model))), 3)*100
targets::tar_load(lactate_model)
equatiomatic::extract_eq(lactate_model)
check_model(lactate_model)
check_homogeneity(lactate_model)
check_heteroscedasticity(lactate_model)
targets::tar_make()
targets::tar_load(lactate_model)
check_model(lactate_model)
check_model(lactate_model)
check_homogeneity(lactate_model)
check_outliers(lactate_model)
check_normality(lactate_model)
check_heteroscedasticity(lactate_model)
sjPlot::plot_model(lactate_model, type = "pred", terms = c("timepoint", "condition"),
show.data = TRUE, jitter = TRUE)
sjPlot::plot_model(sit_reach_model, type = "pred", terms = c("condition", "timepoint", "measurement"),
transform = FALSE)
sjPlot::plot_model(lactate_model, type = "pred", terms = c("timepoint", "condition"),
show.data = TRUE, jitter = TRUE, transform = FALSE)
sjPlot::plot_model(lactate_model, type = "pred", terms = c("timepoint", "condition"),
show.data = TRUE, jitter = TRUE, transform = "log")
sjPlot::plot_model(lactate_model, type = "pred", terms = c("timepoint", "condition"),
show.data = TRUE, jitter = TRUE, transform = NULL)
lactate_data |>
ggplot(aesx=timepoint, y=log(value), color=condition) +
geom_point(position=position_jitter(w=0.1))
ggplot(aes(x=timepoint, y=log(value), color=condition) +
lactate_data |>
ggplot(aes(x=timepoint, y=log(value), color=condition)) +
geom_point(position=position_jitter(w=0.1))
lactate_data |>
lactate_data |>
ggplot(aes(x=timepoint, y=log(value), color=condition)) +
geom_point(position=position_jitter(w=0.1))
lactate_data |>
ggplot(aes(x=condition, y=log(value), color=condition)) +
geom_point(position=position_jitter(w=0.1))
lactate_data |>
ggplot(aes(x=condition, y=log(value), color=condition)) +
geom_point(position=position_jitter(w=0.1)) +
facet_wrap("timepoint")
check_model(lactate_model)
targets::tar_load(borg_rpe_model)
equatiomatic::extract_eq(borg_rpe_model)
check_model(borg_rpe_model)
targets::tar_load(heart_rate_model)
equatiomatic::extract_eq(heart_rate_model)
check_model(heart_rate_model)
check_normality(heart_rate_model)
targets::tar_load(cmj_model)
equatiomatic::extract_eq(cmj_model)
check_model(cmj_model)
check_normality(cmj_model)
check_normality(cmj_model, effects = "random")
targets::tar_load(sprint_model)
equatiomatic::extract_eq(sprint_model)
check_model(sprint_model)
targets::tar_visnetwork()
targets::tar_visnetwork()
targets::tar_visnetwork()
install.packages("quarto")
targets::tar_visnetwork()
targets::tar_make()
targets::tar_load(c(
sit_reach_data,
lactate_data,
borg_rpe_data,
heart_rate_data,
cmj_data,
sprint_data,
imtp_data,
sit_reach_model,
lactate_model,
borg_rpe_model,
heart_rate_model,
cmj_model,
sprint_model,
imtp_model,
sit_reach_model_tidy,
lactate_model_tidy,
borg_rpe_model_tidy,
heart_rate_model_tidy,
cmj_model_tidy,
sprint_model_tidy,
imtp_model_tidy
))
View(sprint_model_tidy)
summary(sit_reach_model
)
tidy(summary(sit_reach_model
))
broom.mixed::tidy(summary(sit_reach_model
))
broom.mixed::tidy(sit_reach_model
)
confint(sit_reach_model
)
sjPlot::tab_model(sit_reach_model
)
sjPlot::tab_model(sit_reach_model, lactate_model
)
